"""
Mini app to generate personalized inspirational phrases about world peace.

The application uses OpenAI's API to create short, poetic messages inspired
by the writings of San Juan de la Cruz and other mystics. The user enters
their name and a meaningful word via a simple web form. The app reflects
internally on the symbolic resonance of the word, then requests a
composition from OpenAI. The response is delivered with a warm greeting and
avoids negative phrasing in line with the "Principio de Frase Afirmativa
Transformadora".

To run this application locally you will need an OpenAI API key set in
the environment variable ``OPENAI_API_KEY``. On Render this can be
configured in the service's environment.

Usage::
    export OPENAI_API_KEY=sk-...
    python app.py

The app will be available at http://localhost:5000 by default.
"""

from __future__ import annotations

import os
from flask import Flask, render_template, request, redirect, url_for
import openai


# Create the Flask application
app = Flask(__name__)


def call_openai_for_phrase(word: str) -> str:
    """Call OpenAI's API to generate an inspirational phrase.

    The phrase is influenced by the provided ``word`` but does not mention it
    explicitly. The prompt instructs the model to draw on the spirit of San
    Juan de la Cruz and other mystics, emphasising peace and avoiding
    negations (e.g. "no", "sin", "nunca").

    Parameters
    ----------
    word : str
        A meaningful word supplied by the user. It guides the imagery and
        metaphors but should not appear in the final sentence.

    Returns
    -------
    str
        A poetic, contemplative phrase generated by the OpenAI API.

    Raises
    ------
    RuntimeError
        If the OpenAI API key is not configured or the API call fails.
    """
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise RuntimeError(
            "OPENAI_API_KEY is not set. Please configure your OpenAI API key as an environment variable."
        )
    openai.api_key = api_key

    # Compose the prompt for the model. We use system and user messages to
    # influence the model's tone and to respect the user's guidelines.
    system_message = (
        "Eres un poeta místico que escribe frases inspiradoras sobre la paz "
        "mundial. Tus palabras están impregnadas de la esencia de San Juan de la Cruz "
        "y otros sabios y místicos. Evitas usar negaciones y transformas todas las "
        "frases en declaraciones afirmativas llenas de luz."
    )
    # The user message includes instructions referencing the user's word
    # indirectly. We avoid quoting the word directly and instruct the model
    # not to use negative constructs.
    user_prompt = (
        f"Crea una frase breve (1‑2 frases) y poética inspirada por la palabra '{word}'. "
        "Explora su significado simbólico y espiritual sin mencionarla explícitamente. "
        "Utiliza metáforas evocadoras para hablar de la paz mundial, la luz y el amor. "
        "Evita usar palabras negativas como 'no', 'sin' o 'nunca'. Mantén un tono cálido, "
        "contemplativo y alentador."
    )

    try:
        completion = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": system_message},
                {"role": "user", "content": user_prompt},
            ],
            max_tokens=120,
            temperature=0.8,
        )
    except Exception as exc:
        raise RuntimeError(f"Error calling OpenAI API: {exc}") from exc

    # Extract the generated content
    generated = completion["choices"][0]["message"]["content"].strip()
    return generated


@app.route("/", methods=["GET", "POST"])
def index():
    """Render the main page and handle form submissions.

    When the method is POST, the form data is used to call the OpenAI API
    and the resulting phrase is presented to the user.

    Returns
    -------
    str
        Rendered HTML for GET and POST requests.
    """
    if request.method == "POST":
        name = request.form.get("nombre_usuario", "").strip()
        word = request.form.get("palabra_importante", "").strip()
        if not name or not word:
            # If either field is empty, redirect back to the form with an error
            return render_template(
                "index.html",
                response=None,
                error="Por favor, completa todos los campos."
            )
        try:
            phrase = call_openai_for_phrase(word)
        except RuntimeError as err:
            return render_template(
                "index.html",
                response=None,
                error=str(err)
            )
        # Build the complete response with the greeting and the generated phrase
        final_response = f"Hola {name}. Aquí tienes tu frase para escribirla en el viento:\n{phrase}"
        return render_template(
            "index.html",
            response=final_response,
            error=None
        )
    # For GET requests, simply render the empty form
    return render_template("index.html", response=None, error=None)


if __name__ == "__main__":
    # When running locally, start the development server
    port = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=port, debug=True)
